Table of Contents=================   * [1.显示有限的接口到外部](#1显示有限的接口到外部)   * [2.filter的用法](#2filter的用法)   * [3.一行作判断](#3一行作判断)   * [4.装饰器之单例](#4装饰器之单例)   * [5.staticmethod装饰器](#5staticmethod装饰器)   * [6.property装饰器](#6property装饰器)   * [7.iter魔法](#7iter魔法)   * [8.神奇partial](#8神奇partial)   * [9.神秘eval](#9神秘eval)   * [10.exec](#10exec)   * [11.etattr](#11etattr)   * [12.命令行处理](#12命令行处理)   * [13.读写csv文件](#13读写csv文件)# 1.显示有限的接口到外部```# 当发布python第三方package时,并不希望代码中的所有函数或者class可以被外部import，在__init__.py中添加__all__属性# 该list中填写可以import的类或者函数名，可以起到限制的import的作用，防止外部import其他函数或者类# !/user/bin/env python# -*- coding:utf-8 -*-from base import APIBasefrom client import Clientfrom decorator import interface, export, streamfrom server import Serverfrom storage import Storagefrom util import (LogFormatter, disable_logging_to_stderr,                  enable_logging_to_kids, info)__all__ = [    'APIBase',    'Client',    'interface',    'export',    'stream',    'Server',    'Storage',    'LogFormatter',    ' disable_logging_to_stderr',    'enable_logging_to_kids',    'info']# 证明了会先执行__enter__方法, 然后调用with内的逻辑, 最后执行__exit__做退出处理, 并且, 即使出现异常也能正常退出```# 2.filter的用法```# 相对filter而言, map和reduce使用的会更频繁一些, filter正如其名字, 按照某种规则过滤掉一些元素list_1 = [1, 2, 3, 4, 5, 6]filter_list = list(filter(lambda x: x % 2 != 0, list_1))# 以此取list_1中的元素是filter的功能print(filter_list)list_1 = [x for x in list_1 if x % 2 != 0]print(list_1)# print(filter(lambda x: x % 2 != 0, list))```# 3.一行作判断```# 当条件满足时, 返回的为等号后面的变量, 否则返回else后语句list1 = [1, 2, 3]new_list = list1[0] if list1 is not None else Noneprint(new_list)```# 4.装饰器之单例```def singleton(cls):    instances = dict()  # 初始为空    def is_singleton(*args, **kwargs):        if cls not in instances:            instances[cls] = cls(*args, **kwargs)            print("我被实现了!!!!")            return instances[cls]        else:            print("不能再实现了!!!!")    return is_singleton@singletonclass Test(object):    passif __name__ == '__main__':    t1 = Test()    t2 = Test()    print(t1)  # <__main__.Test object at 0x000001A8F90B6978>    print(t2)  # None```# 5.staticmethod装饰器```# 类中两种常用的装饰, 首先区分一下他们# classmethod装饰器, 类方法(给人感觉非常类似于OC中的类方法), 其中第一个隐式参数为类# staticmethod装饰器, 没有任何隐式参数. python中的静态方法类似与C++中的静态方法class A(object):    # 普通成员函数    def foo(self, x):        print("executing foo(%s, %s)" % (self, x))    @classmethod  # 使用classmethod进行装饰    def class_foo(cls, x):        print("executing class_foo(%s, %s)" % (cls, x))    @staticmethod  # 使用staticmethod进行装饰    def static_foo(x):        print("executing static_foo(%s)" % (x))def test_three_method():    obj = A()    # 直接调用普通的成员方法    obj.foo("para")  # 此处obj对象作为成员函数的隐式参数，就是self    # executing foo(<__main__.A object at 0x00000248DA01B400>, para)    obj.class_foo("para")  # 此处类作为隐式函数被传入，就是cls    # executing class_foo( <class '__main__.A'>, para)    A.class_foo("para")  # 更直接的类方法调用    # executing class_foo( <class '__main__.A'>, para)    obj.static_foo("para")  # 静态方法并没有任何隐式函数，但是要通过对象或者类进行调用    # executing static_foo(para)    A.static_foo("para")if __name__ == '__main__':    test_three_method()```# 6.property装饰器```# 将property与装饰器结合实现属性私有化(更简单安全的实现get和set方法)# property(fget=None, fset=None, fdel=None, doc=None)# fget是获取属性的值的函数,fset是设置属性值的函数,fdel是删除属性的函数,doc是一个字符串(like a comment)# property有三个方法getter(), setter()和delete() 来指定fget, fset和fdeclass Student(object):    @property    def score(self):        return self._score    @score.setter # 更安全    def score(self, value):        if not isinstance(value, int):            raise ValueError("score must be an integer!")        if value < 0 or value > 100:            raise ValueError('score must between 0~100!')        self._score = value```# 7.iter魔法```# 通过yield和__iter__的结合, 我们可以把一个对象变成可迭代的# 通过__str__的重写, 可以直接通过想要的形式打印对象class TestIter(object):    def __init__(self):        self.list1 = [1, 2, 3, 4, 5]    def read(self):        for ele in range(len(self.list1)):            yield ele    def __iter__(self):        return self.read()    def __str__(self):        return '.'.join(map(str, self.list1))    __repr__ = __str__def test_iter():    obj = TestIter()    for num in obj:        print(num)    print(obj)if __name__ == '__main__':    test_iter()```# 8.神奇partial```# partial使用上很像C++中仿函数(函数对象).def partial(func, *part_args):    def wrapper(*extra_args):        args = list(part_args)        args.extend(extra_args)        return func(*args)    return wrapper()# 利用用闭包的特性绑定预先绑定一些函数参数, 返回一个可调用的变量, 直到真正的调用执行from functools import partialdef sum(a, b):    return a + bdef test_partical():    fun = partial(sum, 2) #事先绑定一个参数， fun成为一个只需要一个参数的可调用变量    print(fun(3)) #实现执行的即是sum（2，3）if __name__ == '__main__':    test_partical()```# 9.神秘eval```# eval我理解为一种内嵌的python解释器(这种解释可能会有偏差), 会解释字符串为对应的代码并执行, 并且将执行结果返回def test_first():    return 3def test_second(num):    return numaction = {    'para': 5,    "test_first": test_first,    "test_second": test_second}def test_eval():    condition = "para == 5 and test_second(test_first) > 5"    res = eval(condition, action)  # 解释condition并根据action对应的动作执行    print(res)if __name__ == '__main__':    test_eval()```# 10.exec```# exec在Python中会忽略返回值, 总是返回None, eval会返回执行代码或语句的返回值# exec和eval在执行代码时, 除了返回值其他行为都相同# 在传入字符串时, 会使用compile(source, '<string>', mode)编译字节码. mode的取值为exec和evaldef test_first():    print("hello")def test_second():    test_first()    print("second")def test_third():    print("third")action = {    "test_second": test_second,    "test_third": test_third}def test_exec():    exec("test_second") in actionif __name__ == '__main__':    test_exec()```# 11.etattr```# 通过string类型的name, 返回对象的name属性(方法)对应的值,#  如果属性不存在, 则返回默认值, 相当于object.nameclass TestGetAttr(object):    test = 'test attribute'    def say(self):        print("test method")def test_getattr():    my_test = TestGetAttr()    try:        print(getattr(my_test, "test"))    except AttributeError:        print("AttributeError!")    try:        getattr(my_test, "say")()    except AttributeError:  # 没有该属性，且没有指定返回值的情况下        print('method Error!')if __name__ == '__main__':    test_getattr()    # test attribute    # test method```# 12.命令行处理```import sysimport optparsedef process_command_line(argv):    """    :param argv: a llist of arguments, or 'None' for 'sys.argv[1]'.    :return: a 2-tuple:(settings object, args list).    """    if argv is None:        argv = sys.argv[1:]    # initialize the parser object    parser = optparse.OptionParser(        formatter=optparse.TitledHelpFormatter(width=78),        add_help_option=None)    parser.add_option(        '-h',        '--help',        action='help',        help='Show this help message and exit.')    settings, args = parser.parse_args(argv)    if args:        parser.error(            'program takes no command-line arguments "%s" ignored.' %            (args,))    return settings, argsdef main(argv=None):    settings, args = process_command_line(argv)    return 0if __name__ == "__main__":    status = main()    sys.exit(status)```# 13.读写csv文件```import csv# 写入with open('data.csv','w') as f:    writer = csv.writer(f)    writer.writerow(['name','address','age'])    data = [('xiaoming','china','10'),            ('lily','USA','12')]    writer.writerow(data)# 读取with open('data.csv','r') as f:    reader = csv.reader(f)    for row in reader:        print(row)```
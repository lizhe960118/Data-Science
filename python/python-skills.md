Table of Contents=================   * [python面试常见问题](#python面试常见问题)      * [1 类继承](#1-类继承)      * [2 方法对象](#2-方法对象)      * [3 new和init](#3-new和init)      * [4 python list和dict生成](#4-python-list和dict生成)      * [5 全局变量和局部变量](#5-全局变量和局部变量)      * [6 交换两个变量的值](#6-交换两个变量的值)      * [7 默认方法](#7-默认方法)      * [8 包管理](#8-包管理)      * [9 闭包](#9-闭包)      * [10 性能](#10-性能)      * [11 final作用域的代码一定会被执行吗?](#11-final作用域的代码一定会被执行吗)      * [12 可以对含有任意的元素的list进行排序吗？](#12-可以对含有任意的元素的list进行排序吗)      * [13 python可是使用  x或者x  之类的操作吗？](#13-python可是使用x或者x之类的操作吗)      * [14 python里如何实现C  里的printf函数？](#14-python里如何实现c里的printf函数)      * [15 python里逗号等号(,=)是什么意思？](#15-python里逗号等号是什么意思)      * [16 如何快速的给python的对象增加属性](#16-如何快速的给python的对象增加属性)      * [17 如何定义一个包含默认值的dict](#17-如何定义一个包含默认值的dict)      * [18 如何计算函数的执行时间](#18-如何计算函数的执行时间)      * [19 如何实现单例模式](#19-如何实现单例模式)      * [20 去掉list中的重复元素](#20-去掉list中的重复元素)      * [21 读取dict中的值](#21-读取dict中的值)      * [22 排序字典](#22-排序字典)      * [23 打印更易读的类](#23-打印更易读的类)      * [24 将类打印成json字符串](#24-将类打印成json字符串)      * [25 排序类列表](#25-排序类列表)      * [26 命令行查看python文档](#26-命令行查看python文档)      * [27 将python代码打包成独立的二进制文件](#27-将python代码打包成独立的二进制文件)      * [28 自动格式化python代码](#28-自动格式化python代码)      * [29 正确的函数返回](#29-正确的函数返回)      * [30 正确使用函数默认参数](#30-正确使用函数默认参数)      * [31 利用元组传递多个函数参数](#31-利用元组传递多个函数参数)      * [32 列表生成器](#32-列表生成器)      * [33 装饰器](#33-装饰器)      * [34 python调用机制](#34-python调用机制)      * [35 描述符](#35-描述符)      * [36 python继承机制](#36-python继承机制)      * [37 python特殊方法](#37-python特殊方法)      * [38 类变量的查找](#38-类变量的查找)      * [39 python3中的除法](#39-python3中的除法)      * [40 超出成员数的索引返回空列表](#40-超出成员数的索引返回空列表)      * [41 闭包导致的函数调用失败](#41-闭包导致的函数调用失败)      * [42 使用可变数据类型当函数变量注意初始化](#42-使用可变数据类型当函数变量注意初始化)# python面试常见问题## 1 类继承```class A(object):    def show(self):        print('base show')class B(A):    def show(self):        print('derived show')obj = B()obj.show()# 调用类A的show方法obj.__class__ = Aobj.show()# __class__方法指向了类对象，只用给他赋值类型A，然后调用方法show，但是用完了记得修改回来。```## 2 方法对象```class A(object):    def __init__(self, a, b):        self.__a = a        self.__b = b    def myprint(self):        print('a = ', self.__a, 'b = ', self.__b)a1 = A(10, 20)a1.myprint()a1(80)# TypeError: 'A' object is not callable# 为了能让对象实例能被直接调用，需要实现__call__方法class A(object):    def __init__(self, a, b):        self.__a = a        self.__b = b    def myprint(self):        print('a = ', self.__a, 'b = ', self.__b)    def __call__(self, num):        print('call', num + self.__a)a1 = A(10, 20)a1.myprint()a1(10)```## 3 new和init```class B(object):    def fn(self):        print('B fn')    def __init__(self):        print('B INIT')class A(object):    def fn(self):        print('A fn')    def __new__(cls, a):        print("NEW", a)        if a > 10:            return super(A, cls).__new__(cls)        return B()    def __init__(self, a):        print('A INIT', a)a1 = A(5)# NEW 5# B INITa1.fn()# B fna2 = A(20)# NEW 20# A INIT 20a2.fn()# A fn# 使用__new__方法，可以决定返回哪个对象，也就是创建对象之前，这个可以用于设计模式的单例、工厂模式。# __init__是创建对象是调用的```## 4 python list和dict生成```ls = [1, 2, 3, 4]list1 = [i for i in ls if i > 2]print(list1)list2 = [i * 2 for i in ls if i > 2]print(list2)dict1 = {x: x ** 2 for x in (2, 4, 6)}print(dict1)dict2 = {x: 'item' + str(x ** 2) for x in (2, 4, 6)}print(dict2)set1 = {x for x in 'hello world' if x not in 'low level'}print(set1)```## 5 全局变量和局部变量```num = 9def f1():    num = 20def f2():    print(num)f2()f1()f2()# f1()中的num不是个全局变量，所以每个函数都得到了自己的num拷贝，# 如果你想修改num，则必须用global关键字声明。比如下面这样num = 9def f1():    global num    num = 20def f2():    print(num)f2()f1()f2()```## 6 交换两个变量的值```a = 8b = 9(a, b) = (b, a)print(a, b)```## 7 默认方法```class A(object):    def __init__(self, a, b):        self.a1 = a        self.b1 = b    def mydefault(self):        print('this is a method for mydefault')a1 = A(10, 20)a1.fn1()a1.fn2()a1.fn3()# AttributeError: 'A' object has no attribute 'fn1'# 改进方法，加入 __getattr__()方法class A(object):    def __init__(self, a, b):        self.a1 = a        self.b1 = b    def mydefault(self):        print('this is a method for mydefault')    def __getattr__(self, name):        return self.mydefaulta1 = A(10, 20)print(a1.a1)a1.fn1()a1.fn2()a1.fn3()# 继续改进# 方法__getattr__只有当没有定义的方法调用时，才是调用他。# 当fn1方法传入参数时，我们可以给mydefault方法增加一个*args不定参数来兼容。class A(object):    def __init__(self, a, b):        self.a1 = a        self.b1 = b    def mydefault(self, *args):        print('this is a method for mydefault ' + str(args[0]))    def __getattr__(self, name):        return self.mydefaulta1 = A(10, 20)print(a1.a1)a1.fn1(33)a1.fn2('hello')a1.fn3(10)```## 8 包管理```# 一个包里有三个模块，mod1.py, mod2.py, mod3.py,但使用 from demopack import *导入模块时，# 如何保证只有mod1，mod3被导入了# 答案：增加 __init__.py 文件，并在文件里增加：__all__ = ['mod1','mod3']```## 9 闭包```# 写一个函数，接收整数参数n，返回一个函数，函数的功能是把函数的参数和n相乘并把结果返回def mulby(num):    def gn(val):        return num * val    return gnzw = mulby(9)print(zw(7))```## 10 性能```# 解析下面的代码慢在哪def strtest1(num):    str = 'first'    for i in range(num):        str += 'x'    return strprint(strtest1(9))# python的str是个不可变对象，每次迭代，都会生成新的str对象来存储新的字符串，# num越大，创建的str对象越多，内存消耗越大。```## 11 final作用域的代码一定会被执行吗?```import timechoice = Truetry:    if choice:        while True:            pass    else:        print("Please pull the plug on your computer sometime soon ...")        time.sleep(60 * 60 * 24 * 365)finally:    print("Finally")# 上面的代码主要是通过让流程停滞在try作用域里，从而实现了需求。上面的代码不排除有点投机取巧的意思，但是我们实习了题目的需求不是吗。```## 12 可以对含有任意的元素的list进行排序吗？```x = [1, 1j]x.sort()# TypeError: '<' not supported between instances of 'complex' and 'int'># python里1j是一个特殊符号代表-1的平方根，出现这个问题的原因是sort函数调用的对象的lt函数来比较两个对象的，而复杂的数字类型是不可比较的，也就说没有实现lt函数，所以比较不了```## 13 python可是使用++x或者x++之类的操作吗？(1) ++x操作是可以的，但是这个操作产生的结果和C语言里该操作产生的结果是不一样的，Python里++x操作里的加好只是一个一元操作符，所以，++x等价于+(+x)，所以++x == x。  (2) x++操作是不合法的，虽然有些情况下，x++看着是合法的，比如：x++-y，但其实这个表达式等价于x+(+(-y)) = x-y，所以正常情况下，x++是不合法的。  > Python里如何实现类似于C++里的cout<<x<<y操作？```import sysclass ostream():    def __init__(self, file):        self.file = file    def __lshift__(self, obj):        self.file.write(str(obj))        return selfcout = ostream(sys.stdout)cerr = ostream(sys.stderr)n1 = '\n'cout << x << "" << y << n1# 这地方并不是展示了一个新的python语法，这只是对python的str对象进行了封装```## 14 python里如何实现C++里的printf函数？在python2中，print是一个表达式，python3里是个函数。所以在python2里，我们可以这么做：```def printf(format, *args):    print format % args,```第一个地方，就是最后使用了逗号结尾，这样的话会更像c++的printf函数，如果想换行，则需要传入换行符。  第二个地方是这个代码会在最后多打印一个空格，如果不想要这个空格，可以使用sys.stdout.write函数。  第三的方面，这行代码除了更像C++风格的printf，还有其他好处吗？当然是有的，参数是比较灵活的。  ## 15 python里逗号等号(,=)是什么意思？```x ,= range(1)print(x)# 实际上，没有逗号等号(,=)这种操作符，上面的代码等价于 (x,) = range(1)。# 这只是一个赋值语句，在左边有一个元组，意味着将元组的每个元素赋给右边的相应元素; 在这种情况下，x被赋值为0```## 16 如何快速的给python的对象增加属性```class Struct:    def __init__(self, **entries):        self.__dict__.update(entries)options = Struct(answer=42, linelen=80, font='courier')print(options.answer)options.answer = 'plastics'print(vars(options))```## 17 如何定义一个包含默认值的dict```# 在python2.7之前，必须定义一个类来处理这样的需求，现在，可以使用collections.defaultdict和collections.Counte来实现。from collections import Counterwords = 'this is a test this is a only test'.split()print(Counter(words))```## 18 如何计算函数的执行时间```def timer(fn, *args):    import time    start = time.clock()    return fn(*args), time.clock() - startprint(timer(max, range(int(1e6))))```## 19 如何实现单例模式```def singleton(object):    cls = object.__class__    if hasattr(cls, '__instantiated'):        raise ValueError(            "%s is a Singleton class but id already instantiated" %            cls)    cls.__instantiatedclass YourClass:    def __init__(self, *args):        singleton(self)```## 20 去掉list中的重复元素```my_list = [3,2,1,1,2,3]print(my_list)unique_list = list(set(my_list))print(unique_list)from collectons import OrderedDict my_list = [3,2,1,1,2,3]print(my_list)unique_list = list(OrderedDict.fromkeys(my_list))print(my_list)#前一种方式不会保留list的元素顺序，后一种方式会保留list的元素顺序。```## 21 读取dict中的值```url_dict = {	'google':'https://www.google.com/',	'github':'https://www.github.com/',	'facebook':'https://www.facebook.com/'}"""不推荐方式"""print(url_dict['facebook'])"""推荐方式"""print(url_dict.get('facebook','https://www.google.com/'))print(url_dict.get('baidu','https://www.google.com/'))#前一种方式读取一个不存在的key时，会导致KeyError，# 例如print url_dict['baidu']，因为字典中不存在baidu，所以会导致KeyError。# 后一种方式使用字典的get方法，如果key不存在，不会产生KeyError，如果给了默认值，会返回默认值，否则返回None```## 22 排序字典```unorder_dict = {'c':1,'b':2,'a':3}print(sorted(unorder_dict.items(), keys=lambda e: e[1]))#按照value升序排序#[('c',1),('b',2),('a',3)]print(sorted(unorder_dict.items(), keys=lambda e: e[0]))#按照key升序排序#[('a',3),('b',2),('c',1)]print(sorted(unorder_dict.items(), keys=lambda e: e[1],reverse = True))# 第三种方式是按字典的value降序排序，和第一种方式相反，因为指定了参数reverse为True。# [('a',3),('b',2),('c',1)]```## 23 打印更易读的类```#不推荐方式class Point(object):	def __init__(self, x, y):		self.x = x		self.y = yp = Point(3,4)print(p)#推荐方式class Point(object):	def __init__(self, x, y):		self.x = x		self.y = y	def __rep__(self):		return 'Point({self.x},{self.y})'.format(self = self)p = Point(3,4)print(p)# 前一种方式打印的类不易读，不能获取更多的信息。通过类的repr方法可以将类打印得更易读。# 或者不定义repr方法，直接使用下面方式打印：# print p.__dict__# {'y': 4, 'x': 3}# 使用dict方法，将类以字典形式打印出来，也比较易读。```## 24 将类打印成json字符串```import jsonclass User(object):	"""docstring for User"""	def __init__(self, name, id):		self.name = name		self.id = idu = User('user1', 1)print(json.dumps(u.__dict__, index=4))# 通过json模块的dumps方法，可以轻易将类打印成json字符串。```## 25 排序类列表```class User(object):	"""docstring for User"""	def __init__(self, name, id):		self.name = name		self.id = id	def __repr__(self):		return 'User({self.name},{self.key})'.format(self=self)user_list = [	User('user1',3),	User('user2',2),	User('user3',1)]print(sorted(user_list, key=lambda user: user.key))# user的key升序排序print(sorted(user_list, key=lambda user: user_name))# 按user的name升序排序user_list = [	User('user1',3),	User('user1',2),	User('user1',1)]print(sorted(user_list, key=lambda user: (user.name, user.key))```## 26 命令行查看python文档```# pydoc sys.exit# 查看sys模块的exit函数文档信息# pydoc sorted# 查看了内建函数sorted的文档信息。```## 27 将python代码打包成独立的二进制文件```# hello_world.py'#!/usr/bin/env python# -*- coding: utf-8 -*-print 'hello, world!''``````python hello_world.py# 使用python直接运行需要编译成独立二进制文件的hello_world.py，程序正常打印hello, world!pip install pyinstaller# 使用pip安装pyinstallerpyinstaller -F hello_world.py# 通过pyinstaller将hello_world.py打包成独立的二进制文件cd ./dist/# 进入当前目录下的dist目录./hello_world# 运行打包成功的二进制文件hello_world```## 28 自动格式化python代码```#!/user/bin/env python# -*- coding:utf-8 -*-import math, sys;def example():	some_tuple = (1,2,3,'a')	some_variable = {	'long':'Long code lines should be wrapped within 79 charcters.',	'other':[math.pi, 100,200,300,9876543210,'This is a long string that goge on'],	'more';{'inner':'this whole logical line should be wrapped.',	some_tuple:[1,20,300,40000,5000000000,60000000000000000000]}	return (some_tuple,some_variable)def example2():	return {'has_key() is deprecated': True}.has_key({'f':2}.has_key(''))class Example3(object):	def __init__(self,bar):		if bar:			bar += 1			bar = bar * bar			return bar		else:			some_string = 'Indetation in multiline strings should not be touched'			return (sys.path, some_string)```## 29 正确的函数返回```# 不推荐方式def divide(a, b):	if b != 0:		return a * 1.0 / bprint divide(1, 0)print divide(0, 1)# 如果输入的参数b为0，函数会默认返回None，这是一个不太好的编程习惯def divide(a, b):	try:		return a * 1.0 / b	except ZeroDivisionError as e:		raise eprint divide(1, 0)print divide(0, 1)# 当把函数的返回值作为if条件判断时，0.0和None都是False，这样容易导致bug。后面这种方式，将除数是0当成异常抛出，让调用者处理异常，是比较合理的做法。```## 30 正确使用函数默认参数```def gen_list(a=[], b=None):	a.append(b)	return bprint gen_list(b = 2)print gen_list(b = 3)# 会导致函数默认值改变，多次调用相互影响。def gen_list(a=None, b=None):	if a is None:		a = []	a.append(b)	return aprint gen_list(b = 2)print gen_list(b = 3)# 将函数默认值设置成None，在函数内部初始化默认参数。这里只是针对传递引用类型的参数，如果是数字、字符串等类型就不存在该问题```## 31 利用元组传递多个函数参数```# 推荐方式def demo(a, b, c, d):	print a, b, c, dargs = (1, 2, 3, 4)demo(*args)```## 32 列表生成器```# 错误做法class A(object):	"""docstring for A"""	x = 1	gen = (x for _ in range(10))if __name__ == '__main__':	print(list(A.gen))# 在 gen=(x for _ in xrange(10)) 中 gen 是一个 generator ,在 generator 中变量有自己的一套作用域，与其余作用域空间相互隔离。# 因此，将会出现这样的 NameError: name 'x' is not defined 的问题，那么解决方案是什么呢？答案是：用 lambda 。#正解class A(object):	x = 1	gen = (lambda x:(x for _ in range(10)))(x)if __name__ == '__main__':	print(list(A.gen))#或者class A(object):	x = 1	gen = (A.x for _ in range(10))if __name__ == '__main__':	print(list(A.gen))```## 33 装饰器```import timeclass Timeit(object):	def __init__(self, func):		self._wrapped = func	def __call__(self, *arg, **kws):		start_time = time.time()		result = self._wrapped(*arg, **kws)		print('elapsed time is %s' % (time.time() - start_time))		return result#正确运行@Timeitdef func():	time.sleep(1)	return 'invoking function func'if __name__ == '__main__':	func()# 出错class A(object):	@Timeit	def func(self):		time.sleep(1)		return 'invoking function func'if __name__ == '__main__':	a = A()	a.func()# TypeError: func() missing 1 required positional argument: 'self'# 使用类装饰器后，在调用 func 函数的过程中其对应的 instance 并不会传递给 __call__ 方法，造成其 mehtod unbound # 改进Timeitimport timeclass Timeit(object):	def __init__(self, func):		self.func = func	def __call__(self, *args, **kwargs):		print('invoking Timer')	def __get__(self, instance, owner):		return lambda *args, **kwargs:self.func(instance, *args, **kwargs)class A(object):	@Timeit	def func(self):		time.sleep(1)		return 'invoking function func'if __name__ == '__main__':	a = A()	a.func()```## 34 python调用机制```class A(object):	def __call__(self):		print("invoking __call__ from A!")	if __name__ == '__main__':	a = A()	a.__call__ = lambda:"invoking __call__ from lambda"	a.__call__()	a()# 在 Python 中，新式类（ new class )的内建特殊方法，和实例的属性字典是相互隔离的# a.__call__=lambda:"invoking __call__ from lambda" 时，# 的确在我们在 a.__dict__ 中新增加了一个 key 为 __call__ 的 item# 但是当我们执行 a() 时，因为涉及特殊方法的调用，# 因此我们的调用过程不会从 a.__dict__ 中寻找属性，而是从 type(a).__dict__ 中寻找属性```## 35 描述符```# 我想写一个 Exam 类，其属性 math 为 [0,100] 的整数，# 若赋值时不在此范围内则抛出异常，我决定用描述符来实现这个需求。class Grade(object):	def __init__(self):		self._sorce = 0	def __get__(self, instance, owner):		return self._score	def __set__(self, instance, value):		if 0 <= value <= 100:			self._score = value		else:			raise ValueError('grade must be betwwen 0 and 100')class Exam(object):	math = Grade()	def __init__(self, math):		self.math = mathif __name__ == '__main__':	niche = Exam(math = 90)	print(niche.math)	snake = Exam(math = 70)	print(snake.math)	print(niche.math)	# snake.math = 120# 再运行一次 print(niche.math) 你就会发现，输出值是 70 ，那么这是为什么呢？# 这就要先从 Python 的调用机制说起了。# 我们如果调用一个属性，那么其顺序是优先从实例的 __dict__ 里查找，# 然后如果没有查找到的话，那么一次查询类字典，父类字典，直到彻底查不到为止。# 好的，现在回到我们的问题，我们发现，在我们的类 Exam 中，# 其 self.math 的调用过程是，首先在实例化后的实例的 __dict__ 中进行查找，没有找到，# 接着往上一级，在我们的类 Exam 中进行查找，好的找到了，返回。# 那么这意味着，我们对于 self.math 的所有操作都是对于类变量 math 的操作。# 因此造成变量污染的问题。class Grad(object):	def __init__(self):		self._grade_pool = {}	def __get__(self, instance, owner):		return self._grade_pool.get(instance, None)	def __set__(self, instance, value):		if 0 <= value <= 100:			_grade_pool = self.__dict__.setdefault('_grade_pool',{})			_grade_pool[instance] = value		else:			raise ValueError('fuck')# 那么该则怎么解决呢？很多同志可能会说，恩，在 __set__ 函数中将值设置到具体的实例字典不就行了。# 那么这样可不可以呢？答案是，很明显不得行啊，至于为什么，就涉及到我们 Python 描述符的机制了，# 描述符指的是实现了描述符协议的特殊的类，三个描述符协议指的是 __get__ , ‘set‘ , __delete__ 以及 Python 3.6 中新增的 __set_name__ 方法，# 其中实现了 __get__ 以及 __set__ / __delete__ / __set_name__ 的是 Data descriptors ，而只实现了 __get__ 的是 Non-Data descriptor 。# 那么有什么区别呢，前面说了， 我们如果调用一个属性，那么其顺序是优先从实例的 __dict__ 里查找，然后如果没有查找到的话，那么一次查询类字典，父类字典，直到彻底查不到为止。 # 但是，这里没有考虑描述符的因素进去，如果将描述符因素考虑进去，那么正确的表述应该是我们如果调用一个属性，# 那么其顺序是优先从实例的 __dict__ 里查找，然后如果没有查找到的话，那么一次查询类字典，父类字典，直到彻底查不到为止。# 其中如果在类实例字典中的该属性是一个 Data descriptors ，那么无论实例字典中存在该属性与否，无条件走描述符协议进行调用，在类实例字典中的该属性是一个 Non-Data descriptors ，# 那么优先调用实例字典中的属性值而不触发描述符协议，如果实例字典中不存在该属性值，那么触发 Non-Data descriptor 的描述符协议。# 回到之前的问题，我们即使在 __set__ 将具体的属性写入实例字典中，但是由于类字典中存在着 Data descriptors ，因此，我们在调用 math 属性时，依旧会触发描述符协议。# 经过改良的做法，利用 dict 的 key 唯一性，将具体的值与实例进行绑定，但是同时带来了内存泄露的问题。那么为什么会造成内存泄露呢，# 首先复习下我们的 dict 的特性，dict 最重要的一个特性，就是凡可 hash 的对象皆可为 key ，# dict 通过利用的 hash 值的唯一性（严格意义上来讲并不是唯一，而是其 hash 值碰撞几率极小，近似认定其唯一）来保证 key 的不重复性，# 同时（敲黑板，重点来了），dict 中的 key 引用是强引用类型，会造成对应对象的引用计数的增加，可能造成对象无法被 gc ，从而产生内存泄露。# 解决方法# 第一种：class Grad(object):	def __init__(self):		import weakref		self._grade_pool = weakref.WeakKeyDictionary()	def __get__(self, instance, owner):		return self._grade_pool.get(instance, None)	def __set__(self, instance, value):		if 0 <= value <= 100:			_grade_pool = self.__dict__.setdefault('_grade_pool',{})			_grade_pool[instance] = value		else:			raise ValueError('fuck')# weakref 库中的 WeakKeyDictionary 所产生的字典的 key 对于对象的引用是弱引用类型，其不会造成内存引用计数的增加，因此不会造成内存泄露。# 同理，如果我们为了避免 value 对于对象的强引用，我们可以使用 WeakValueDictionary 。# 第二种# 在 Python 3.6 中，实现的 PEP 487 提案，为描述符新增加了一个协议，我们可以用其来绑定对应的对象：class Grad(object):	def __get__(self, instance, owner):		return instance.__dict__[self.key]	def __set__(self, instance, value):		if 0 <= value <= 100:			instance.__dict__[self.key] = value		else:			raise ValueError("wrong")	def __set_name__(self, owner, name):		self.key = name```## 36 python继承机制```class Init(object):	def __init__(self, value):		self.val = valueclass Add2(Init):	def __init__(self, val):		super(Add2, self).__init__(val)		self.val += 2class Mul5(Init):	def __init__(self, val):		super(Mul5, self).__init__(val)		self.val *= 5class Pro(Mul5, Add2):	passclass Incr(Pro):	csup = super(Pro)	def __init__(self, val):		self.csup.__init__(val)		self.val += 1p = Incr(5)print(p.val)```## 37 python特殊方法```# 通过重载 new 方法来实现单例模式的类class Singleton(object):	_instance = None	def __new__(cls, *args, **kwargs):		if cls._instance:			return cls._instance	cls._instance = cv = object.__new__(cls, *args, **kwargs)	return cvsin1 = Singleton()sin2 = Singleton()print(sin1 in sin2)# 现在我有一堆类要实现为单例模式，所以我打算照葫芦画瓢写一个元类，这样可以让代码复用：class SingleMeta(type):	def __init__(cls, name, bases, dict):		cls._instance = None		__new__o = cls.__new__	def __new__(cls, *arg, **kwargs):		if cls._instance:			return cls._instance		cls._instance = cv = __new__o(cls, *args, **kwargs)		return cv	cls.__new__ = __new__class A(object):	__metaclass__ = SingleMetaa1 = A()# 为啥这会报错啊，我明明之前用这种方法给 __getattribute__ 打补丁的，下面这段代码能够捕获一切属性调用并打印参数class TraceAttribute(type):	def __init__(cls, name, bases, dict):		__getattribute__o = cls.__getattribute__		def __getattribute__(self, *arg, **kwargs):			print('__getattribute__:',args,kwargs)			return __getattribute__o(self,*args,**kwargs)		cls.__getattribute__ = __getattribute__class A(object):	__metaclass__ = TraceAttribute	a = 1	b = 2a = A()a.aa.b# 为什么给 getattribute 打补丁成功，而 new 打补丁失败。# 如果我坚持使用元类给 new 打补丁来实现单例模式，应该怎么修改？# 类里的 __new__ 是一个 staticmethod 因此替换的时候必须以 staticmethod进行替换# 答案如下：class SingleMeta(type):	def __init__(cls, name, bases, dict):		cls._instance = None		__new__o = cls.__new__		@staticmethod		def __new__(cls, *args, **kwargs):			if cls._instance:				return cls._instance			cls._instance = cv = __new__0(cls, *args, *kwargs)			return cv		cls.__new__ = __new__class A(object):	__metaclass__ = SingleMetaprint(A() is A())```## 38 类变量的查找如果一个类的名字在当前类的字典中没有发现，将搜索其父类，直到变量名被找到。```class Parent(object):    x = 1class Child1(Parent):    passclass Child2(Parent):    passprint(Parent.x, Child1.x, Child2.x)# 1 1 1Child1.x = 2print(Parent.x, Child1.x, Child2.x)# 1 2 1Parent.x = 3print(Parent.x, Child1.x, Child2.x)# 3 2 3# 为什么改变了 Parent.x 的值还会改变 Child2.x 的值，但是同时 Child1.x 值却没有改变？# 在 Python 中，类变量在内部是作为字典处理的。如果一个变量的名字没有在当前类的字典中发现，将搜索祖先类（比如父类）直到被引用的变量名被找到# （如果这个被引用的变量名既没有在自己所在的类又没有在祖先类中找到，会引发一个 AttributeError 异常 ）。# 如果该值在父类中被改变（例如，我们执行语句 Parent.x = 3），这个改变会影响到任何未重写该值的子类当中的值（在这个示例中被影响的子类是 Child2）。这就是为什么第三个 print 输出是 3 2 3。```## 39 python3中的除法```# / 做浮点除法， // 做整除运算def div1(x, y):    print("%s/%s = %s" % (x, y, x / y))def div2(x, y):    print("%s//%s = %s" %(x, y, x // y)) # 做整除运算div1(5, 2)div1(5., 2)div2(5, 2)div2(5., 2)# 在 Python 3 中，/ 操作符是做浮点除法，而 // 是做整除（即商没有余数，比如 10 // 3 其结果就为 3，余数会被截除掉，# 而 (-7) // 3 的结果却是 -3。这个算法与其它很多编程语言不一样，需要注意，它们的整除运算会向0的方向取值。# 而在 Python 2 中，/ 就是整除，即和 Python 3 中的 // 操作符一样）```## 40 超出成员数的索引返回空列表试图访问一个列表的以超出列表成员数作为开始索引的切片将不会导致 IndexError，并且将仅仅返回一个空列表。```list1 = ['a', 'b', 'c', 'd', 'e']print(list1[10:])# []```## 41 闭包导致的函数调用失败 由于闭包导致的函数调用失败```def multipliers():    return [lambda x:i * x for i in range(4)]print([m(2) for m in multipliers()])[6, 6, 6, 6]# Python 的闭包的后期绑定导致的 late binding，这意味着在闭包中的变量是在内部函数被调用的时候被查找。# 所以结果是，当任何 multipliers() 返回的函数被调用，在那时，i 的值是在它被调用时的周围作用域中查找，# 到那时，无论哪个返回的函数被调用，for 循环都已经完成了，i 最后的值是 3，因此，每个返回的函数 multiplies 的值都是 3。# 最普遍的解决方案是创建一个闭包，通过使用默认参数立即绑定它的参数def multipliers():    return [lambda x, i=i:i * x for i in range(4)]print([m(2) for m in multipliers()])# [0, 2, 4, 6]# 另外一个选择是，你可以使用 functools.partial 函数：from functools import partialfrom operator import muldef multipliers():    return [partial(mul, i) for i in range(4)]print([m(2) for m in multipliers()])```## 42 使用可变数据类型当函数变量注意初始化```可变数据类型当作函数变量，只在定义时被创建一次def extendList(val, list1=[]):    list1.append(val)    return list1list_1 = extendList(10)list_2 = extendList(123, [])list_3 = extendList('a')print('list1 = %s' % list_1)print('list2 = %s' % list_2)print('list3 = %s' % list_3)# list1 = [10, 'a']# list2 = [123]# list3 = [10, 'a']def extendList(val, list1 = None):    if list1 is None:        list1 = []    list1.append(val) #当外部有输入的时候，所有append操作在判断语句的外部    return list1list_1 = extendList(10)list_2 = extendList(123, [])list_3 = extendList('a')print('list1 = %s' % list_1)print('list2 = %s' % list_2)print('list3 = %s' % list_3)# list1 = [10]# list2 = [123]# list3 = ['a']```
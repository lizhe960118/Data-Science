**Table of Contents*** [python语言特性](#python语言特性)  * [1. python中容易出错的三个问题](#1-python中容易出错的三个问题)  * [2. python2与python3编码的区别](#2-python2与python3编码的区别)  * [3. 判断文件是否存在](#3-判断文件是否存在)  * [4. 改写函数访问二维数组](#4-改写函数访问二维数组)  * [5. python 中的 *args 和 ** kw](#5-python中的*args和**kw)  * [6. 用python实现单例模式](#6-用python实现单例模式)  * [7. finally和return的混用](#7-finally和return的混用)  * [8. python中对象、类型、元类之间的关系](#8-python中对象、类型、元类之间的关系)  * [9. 链式赋值](#9-链式赋值)  * [10. 时间处理](#10-时间处理)  * [11. 给dict设置默认值](#11-给dict设置默认值)  * [12. 列表去重的快速方法](#12-列表去重的快速方法)  * [13. 列表深复制](#13-列表深复制)  * [14. 字典深复制](#14-字典深复制)  * [15. 时间转换相关](#15-时间转换相关)  * [16. 使用map作iterator](#16-使用map作iterator)  * [17. 判断奇数](#17-判断奇数)  * [18. dict删除key](#18-dict删除key)  * [19. 页面重定向](#19-页面重定向)  * [20. 元组进阶](#20-元组进阶)  * [21. 切片进阶](#21-切片进阶)  * [22. 为什么下标要从0开始](#22-为什么下标要从0开始)  * [23. 导入模块的作用范围](#23-导入模块的作用范围)  * [24. with语句中的上下文对象处理](#24-with语句中的上下文对象处理)  * [25. tuple只有一个对象的使用](#25-tuple只有一个对象的使用)  * [26. class定义与def的区别](#26-class定义与def的区别)# python语言特性## 1 Python中容易出错的三个问题- 1.可变数据类型作为函数定义中的默认参数```def search_for_links(page, add_to = []):    new_links = page.search_for_links()    add_to.extend(new_links)    return add_to#应该改为：def search_for_links(page, add_to = None):    if not add_to:        add_to = []     new_links = page.search_for_links()     add_to.extend(new_links)     return add_todef fn(var1, var2 = []):    var2.append(var1) #下一次执行的时候，var2不初始化    print(var2)fn(3)fn(4)fn(5)def fn_new(var1, var2 = None):    if not var2:# var is None        var2 = []    var2.append(var1)    print(var2)fn_new(3)fn_new(4)fn_new(5)# 对于不可变数据类型，比如元组、字符串、整型，是不需要考虑这种情况的# 例如：def func(message = "my message"):    return message```- 2.可变数据类型作为类变量```class URLCatcher(object):    urls = []    def add_url(self, url):        self.urls.append(url)a = URLCatcher()a.add_url("http://www.google.com")b = URLCatcher()b.add_url("http://www.bbc.co.hk")print(b.urls)# ['http://www.google.com', 'http://www.bbc.co.hk']print(a.urls)# ['http://www.google.com', 'http://www.bbc.co.hk']# 创建类定义时，URL 列表将被实例化。该类所有的实例使用相同的列表。# 我们希望每个对象有一个单独的存储，应该修改代码为：class URLCatcher(object):    def __init__(self):        self.urls = []    def add_url(self, url):        self.urls.append(url)a = URLCatcher()a.add_url("http://www.google.com")b = URLCatcher()b.add_url("http://www.bbc.co.hk")print(b.urls)# ['http://www.bbc.co.hk']print(a.urls)# ['http://www.google.com']# 当创建对象时，URL 列表被实例化。当我们实例化两个单独的对象时，它们将分别使用两个单独的列表。```- 3.可变的分配错误```a = {'1': "one",     '2': "two"     }b = ab['3'] = "three"print(a)# {'1': 'one', '2': 'two', '3': 'three'}print(b)# {'1': 'one', '2': 'two', '3': 'three'}c = (2, 3)d = cd = (4, 5)print(c)# (2, 3)# 如果我们真的需要复制一个列表进行处理，我们可以这样做：b = a[:]# 这将遍历并复制列表中的每个对象的引用，并且把它放在一个新的列表中。# 但是要注意：如果列表中的每个对象都是可变的(可迭代的)，我们将再次获得它们的引用，而不是完整的副本。# 字典以相同的方式工作，并且你可以通过以下方式创建一个昂贵副本：b = a.copy()# 再次说明，这会创建一个新的字典，指向原来存在的相同的条目a = {'1': "one",     '2': "two"     }b = a.copy()b['3'] = "three"print(a)# {'1': 'one', '2': 'two'}print(b)# {'1': 'one', '2': 'two', '3': 'three'}```##2  Python2与Python3编码的区别```# 在Python2中，字符串字面量对应于8位的字符或面向字节编码的字节字面量。# 这些字符串的一个重要限制是它们无法完全地支持国际字符集和Unicode编码。# 为了解决这种限制，Python2对Unicode数据使用了单独的字符串类型。# 要输入Unicode字符串字面量，要在第一个引号前加上前最'u'。# Python2中还有一种称为字节字面量的字符串类型，它是指一个已经编码的字符串字面量，# 在Python2中字节字面量和普通字符串没有差别，# 因为在Python2中普通字符串实际上就是已经编码(非Unicode)的字节字符串。# 在Python3中，不必加入这个前缀字符，否则是语法错误，这是因为所有的字符串默认已经是Unicode编码了.# 如果使用-U选项运行解释器，Python2会模拟这种行为(即所有字符串字面量将被作为Unicode字符对待，u前缀可以省略)。# 在Python3中，字节字面量变成了与普通字符串不同的类型。s = '今天练习1'# c = s.encode('utf-8')print(s)# print(s.encode('utf-8').decode('utf-8'))# print(c)def main():    print('今天练习2')print(__name__)# _name__的值为"__main__"if __name__ == '__main__':    main()    print('今天练习3')```## 3 判断文件是否存在```# 一. 使用OS模块# 1.判断文件是否存在import osos.path.exits('test_file.txt')os.path.exits('no_exist_file.txt')# 2.判断文件夹是否存在import osos.path.exists('test_dir')os.path.exists('no_exist_dir')# 3.只检查文件import osos.path.isfile("test-data")# 4.判断文件是否可做读写操作#os.access(, )# 判断文件是否存在os.F_OK()# 检查文件是否可读os.R_OK# 检查文件是否可以写入os.W_OK# 检查文件是否可以执行os.X_OK#判断文件路径是否存在和各种访问模式的权限import osif os.access("/file/path/foo.text", os.F_OK)    print("Given file path is exist")# 二、使用Try语句try:    f = open("test.file")    f.close()except FileNotFoundError:    print("File is not found")except PersmissionError:    print("You don't have permission to access this file")# 三.使用pathlib模块# 使用pathlib需要先使用文件路径来创建path对象。# 检查路径是否存在import pathlibpath = pathlib.Path("path/file")print(path.exist())# 检查路径是否是文件path = pathlib.Path("path/file")print(path.is_file())```## 4 改写函数访问二维数组```class Array:	def __init__(self, lst):	    self.__coll = lst		def __repr__(self):	    return '{!r}'.format(self.__coll)		def __getitem__(self, key):	    slice1, slice2 = key	    row1 = slice1.start	    row2 = slice1.stop	    col1 = slice2.start	    col2 = slice2.stop	    return [self.__coll[r][col1:col2] for r in range(row1, row2)]a = Array([["a", "b", "c", "d"],           ["e", "f", "g", "h"],           ["i", "j", "k", "l"],           ["m", "n", "o", "p"],           ["q", "r", "s", "t"],           ["u", "v", "w", "x"]           ])print(a[1:5, 1:3])```## 5 python中的\*args和\*\*kw```# *args 非关键字参数，用于元组# **kw 关键字参数，用于字典（kwyword）# 1.*argsdef tupleArgs(arg1, arg2 = "b", *arg3):	print('arg1 : %s' % arg1)	print('arg2 : %s' % arg2)	for eachArgNum in range(len(arg3)):		print('the %d in arg3 : %s' % (eachArgNum, arg3[eachArgNum]))if __name__ == '__main__':	tupleArgs("A")	# arg1 : A	# arg2 : b	tupleArgs("23",'c')	# arg1 :  23	# arg2 :  c	tupleArgs('23','a','lol','bupt')	# arg1 : 23	# arg2 : a	# the 0 in arg3 : lol	# the 1 in arg3 : bupt# 2.**kwdef dictKw(kw1, kw2 = "b", **kw3):	print('kw1 : %s' % kw1)	print('kw2 : %s' % kw2)	for eachKw in kw3:		print('the %s -----> %s' % (eachKw, kw3[eachKw]))if __name__ == '__main__':	dictKw("A")	# kw1 : A	# kw2 : b	dictKw("23",'c')	# kw1 :  23	# kw2 :  c	dictKw('23','a',c = 'lol', d = 'bupt')	# kw1 : 23	# kw2 : a	# the c -----> lol	# the d -----> bupt	dictKw('dianzi', c = 'lol', d = 'bupt', kw = 'guangxian')	# kw1 : dianzi	# kw2 : b	# the c -----> lol	# the d -----> bupt	# the kw -----> guangxian```## 6 用Python实现单例模式```# 方法一：使用__new__()# 将类的实例与一个类变量 _instance 关联起来# 如果_instance为None 则创建实例，# 否则返回 cls._instanceclass Singleton(object):    # _instance = None    def __new__(cls):        if not hasattr(cls, 'instance'):            cls.instance = super(Singleton, cls).__new__(cls)        return cls.instanceobj1 = Singleton()obj2 = Singleton()obj1.attr1 = '我是独一无二的attr'print(obj1.attr1, obj2.attr1)print(obj1 == obj2)print(id(obj1), id(obj2))# 方法二：使用装饰器。# 定义一个装饰器singleton, 它返回一个内部函数 getinstance，# 该函数判断某个类是否在字典instances 中。# 如果不存在，则将 cls 作为 key，cls(args. *kw) 作为value 存到instances 中# 如果存在，则返回 instances[cls]from functools import wrapsdef singleton(cls):	instances = {}	@wraps(cls)	def getinstance(*arg, **kw):		if cls  not in instances:			instances[cls] = cls(*arg, **kw)		return instances[cls]	return getinstance@singletonclass Singleton(object):	passobj1 = Singleton()obj2 = Singleton()obj1.attr1 = '我是独二无二的attr'print(obj1.attr1, obj2.attr1)print(obj1 == obj2)print(id(obj1), id(obj2))```## 7 finally和return的混用```import disdef test():    try:        a = 2        return a    except:        pass    finally:        print('finally')s = test()print(s)# finally# 2print(dis.dis(test))```## 8 python中对象、类型、元类之间的关系```# 1.所有对象都有三个特性：id、类型、值print(id(1))1435459744print(type(1))<class 'int'># 2.每个对象都是由对应的类创建出来的class A(object):    passclass B(A):    passprint(A.__bases__)# (<class 'object'>,)print(B.__bases__)# (<class '__main__.A'>,)# 3.元类class A(object):    passprint(id(A))print(type(A))# 6478840# <class 'type'>print(dir(A))print(object)# <class 'object'>print(type)# <class 'type'>print(type(object))# <class 'type'>print(type(type))# <class 'type'>print(type.__bases__)# (<class 'object'>,)print(object.__bases__)# ()```## 9 链式赋值链式赋值就是同时对几个变量进行赋值，如：a = b = c = 3```s = [1, 2, 3, 4, 5, 6]i = 0i = s[i] = 3print(s)# [1, 2, 3, 3, 5, 6]print(i)# 3```> s的列表, 并没有像我们想象中的那样, 就i=0位置上的元素, 变成3, 而是将i=3位置的元素改成3了第3句先将 3 复制一份复制给 i，再将3赋值给是s[2]我们以前总是觉得, 赋值要从右到左依次执行, 先执行 s[i] = 3, 再执行 i=3,然而这些是类似c语言这类支持表达式赋值才允许的. 在c语言中, s = 3表达式是有返回值的. 它会返回赋值的结果3, 所以在它们的链式赋值中, 是将右边表达式的返回值, 再赋值给左边的。在Python是不支持这种赋值语句赋值的, 如果硬要a = (s = 3)只会触发SyntaxError: invalid syntaxa = (s = 3)出错的原因是因为s = 3是赋值语句，而不是表达式。>python的表达式是由操作符连接而成的，但“=”在Python中并不是操作符（Operator），只是语法分隔符（Delimiters）。## 10 时间处理```# 一.壁挂钟时间# 1.time()import timeprint(time.time())# 返回纪元开始的秒数，返回值为浮点数# 2.ctime()import timeprint(time.ctime())later = time.time() + 5print(time.ctime(later))# 用于存储和比较日期# 二，处理器时钟时间clock() # 返回处理器时钟时间import timeprint(time.clock())# 三，时间组成# time模块定义了struct_time来维护时间和日期，其中分开存储各个组成部分import timedef show_struct(s):    print('tm_year:', s.tm_year)    print('tm_mon', s.tm_mon)    print('tm_mday', s.tm_mday)    print('tm_hour', s.tm_hour)    print('tm_min', s.tm_min)    print('tm_sec', s.tm_sec)    print('tm_wday', s.tm_wday)    print('tm_yday', s.tm_yday)show_struct(time.gmtime())# 获取UTC时间 格林尼治时间show_struct(time.localtime())# 获取当前时区的当前时间# 四.处理时区# 1.获取时间差import timeprint(time.timezone/3600)# 2.设置时差import osZONES = ['GMT', 'EUROPE/Amsterdam']for zone in ZONES:    os.environ['TZ'] = zone    # time.tzset()# 五.解析和格式化时间# 1.strptime()# 将字符串时间转换为struct_time格式import timenow = time.ctime()print(time.strptime(now))# 2.strftime()# 用于时间的格式化输出from time import gmtime, strftimeprint(strftime('%a, %d %b %Y %H:%M:%S + 0000', gmtime()))# 3.mktime()# 用于将struct_time转换成时间的浮点数表示from time import mktime, gmtimeprint(mktime(gmtime()))# 六.sleep()import timedef funcn():    print("Please wait for 5 seconds")    time.sleep(5)    print("Hello,world")funcn()```## 11 给dict设置默认值```from collections import defaultdictcontext = defaultdict(list)# setdefault一次只能设置一个值，但是好处是只能使用链式语法，# 但defaultdict更快一些：context = {}context.setdefault('name_list', []).append('Fiona')# 或者用fromkeys, 用法dict.fromkeys(seq[,value]),value默认是国际惯例的None：name_list = ['kevin', 'robin']context = {}.fromkeys(name_list, 9)print(context)# {'kevin': 9, 'robin': 9}context = dict.fromkeys([1, 2], True)print(context)# {1: True, 2: True}```## 12 列表去重的快速方法```# http://www.peterbe.com/plog/uniqifiers-benchmark{}.fromkeys(mylist).keys()```## 13 列表深复制```a = [3, 2, 1]b = a[:]print(b)# [3, 2, 1]a[1] = 4print(a, b)# [3, 4, 1] [3, 2, 1]```## 14 字典深复制```a = {'male': 0, 'female': 1}b = a.copy()print(b)a['male'] = 2print(a, b)# {'male': 2, 'female': 1} {'male': 0, 'female': 1}```## 15 时间转换相关```# 获取今天的年月日时间（date）from datetime import datetimen_date1 = datetime.now().date()n_date2 = datetime.today().date()print(n_date1, n_date2)# 2018-03-30 2018-03-30# date -> datetimefrom datetime import datetimen_date = datetime.now().date()b = datetime.combine(n_date, datetime.now().time())print(b)# 2018-03-30 23:03:50.581855# datetime -> datefrom datetime import datetimea = datetime(2015, 6, 5, 11, 45, 45)print(a)# 2015-06-05 11:45:45 创建一个datetime对象b = a.date()print(b)# 获取datetime对象的时间# time.struct_time -> datetime# 一般time.localtime() 或者用 time.striptime()得到的就是time.struct_timeimport timefrom datetime import  datetimestructTime = time.localtime()print(structTime)# time.struct_time(tm_year=2018, tm_mon=3, tm_mday=30, tm_hour=23, tm_min=20, tm_sec=24, tm_wday=4, tm_yday=89, tm_isdst=0)print(datetime(*structTime[:6]))# 2018-03-30 23:22:01# 或者使用datetime.fromtimestamp, 但是要注意此处的时间不能早于1970-01-01 00:00from time import mktimefrom datetime import datetimeimport timestruct = time.localtime()dt = datetime.fromtimestamp(mktime(struct))print(dt)# 2018-03-30 23:25:36# 计算日期之差from datetime import datetimed0 = datetime(2008, 8, 18)d1 = datetime(2008, 9, 26)delta = d0 - d1print(delta.days)# -39# 获取milliseconds(13位数字)import timefrom datetime import datetimeprint(time.time())# 1522423781.8633723print(int(time.time() * 1000))# 1522423817683# 或者def unix_time_milliseconds():    time_gap = datetime.utcnow() - datetime.utcfromtimestamp(0)    return int(time_gap.total_seconds() * 1000)if __name__ == '__main__':    print(unix_time_milliseconds())    # 1522424185131```## 16 使用map作iterator```# 当将func设置为None时，可起到iterator的作用，结果类似于使用了zip，唯一的区别是map可以按最长的列表扩展。print(map(None, range(3), range(10, 12)))print(zip(range(3), range(10, 12)))```## 17 判断奇数```if a & 1:    print('it is even')```## 18 dict删除key```# 要删除的key数量较多的话（超过一半），建议重新生成dict;# 如果数量较少，在pop和del都可以的情况下，del稍快一些python -m timeit -s "d = {'f': 1, 'foo':2, 'bar':3}" "d1 = d.copy()" "for k in d1.keys():" "if k.startwith('f'):" "del d1[k]"python -m timeit -s "d = {'f': 1, 'foo':2, 'bar':3}" "d1 = d.copy()" "for k in d1.keys():" "if k.startwith('f'):" "d1.pop(k)"```## 19 页面重定向```@app.route('/',defaults = {'path':''},methods = ['GET', 'POST'])@app.route('/<path:path.', methods = ['GET','POST'])def root(path):	"""	路由所有URL	：param path:	:return:	"""	redirect_url = get_redirect_url()	if redirect_url is None:		abort(401)	return redirect(redirect_url, code = 301)# 其中，get_redirect_url()函数为获取重定向的URL，可以根据头部的相关的信息确定# 可以将订单号写入headers，根据订单号的不同规则确定不同的调用地址：def get_redirect_url():	"""	查询路由地址	"""	order_id = request.headers.get('x-tymh-order-id', None)	if order_id is None:		return None	if len(order_id) == 12 and order_id.startwith('7006'):		return 'http://pyplatform/order%s' % ('' if len(request.query_string) == 0 else '?' + request.query_string)	elif len(order_id) == 18 and order_id.startwith('1000000123'):		return 'http://recharge/order%s' % ('' if len(request.query_string) == 0 else '?' + request.query_string)	return 'http://order%s' % ('' if len(request.query_string) == 0 else '?' + request.query_string)```## 20 元组进阶### 元组元组其实是对数据的记录：元组中的每个元素都存放了记录中一个字段的数据，外加这个数据的位置。```lax_coordinates = (33.9425, -118.408056)  # 洛杉矶国际机场的经纬度city, year, pop, chg, area = (    'Tokyo', 2003, 32450, 0.66, 8014)  # 东京的一些信息：市名、年份、人口、人口变化和面积# 以上这两个元组每个位置都对应一个数据记录。```### 元组拆包```city, year, pop, chg, area = ('Tokyo', 2003, 32450, 0.66, 8014)# 这个例子中，我们把元组的数据用一条语句分别赋值给 city, year, pop, chg, area，这就是元组拆包的一个具体应用。# 元组拆包可以应用到任何可迭代对象上，但是被迭代的对象窄的元素的数量必须跟接受这些元素的元组的空档数一致。latitude, longitude = lax_coordinatesprint(latitude, longitude)# 还可以用 * 运算符把一个可迭代对象拆开作为函数的参数：print(divmod(20, 8))t = (20, 8)print(divmod(*t))quotient, remainder = divmod(*t)print(quotient, remainder)# 在进行拆包是，我们可能对元组的某些值并不感兴趣，这时可以用 _ 占位符处理。比如：_, remainder = divmod(20, 8)print(remainder)# 在处理函数参数时，我们经常用*args来表示不确定数量的参数。在python3中，这个概念被扩展到了平行赋值中：a, b, *rest = range(5)print(a, b, rest)# * 前缀只能用在一个变量名前，这个变量可以在其他位置a, *rest, c, d = range(5)print(a, *rest, c, d)a, b, *rest = range(2)print(a, b, *rest)# 元组也支持嵌套拆包，比如：l = (1, 2, 3, (4, 5))a, b, c, (d, e) = lprint(d)```### 具名元组```# 元组作为记录除了位置以外还少一个功能，那就是无法给字段命名，namedtuple解决了这个问题。from collections import namedtupleCity = namedtuple("City", 'name country population coordinates')tokyo = City('Tokyo', 'JP', 36.933, (35.689722, 139.691667))print(tokyo.population)print(tokyo[1])print(City._fields)  # _fields属性是一个包含这个类所有字段名的元组tokyo_data = ('Tokyo', 'JP', 36.933, (35.689722, 139.691667))tokyo = City._make(tokyo_data)# _make() 方法接受一个可迭代对象生成这个类的实例，和 City(*tokyo_data) 作用一致print(tokyo._asdict())  # asdict() 把具名元组以 collections.OrderedDict 的形式呈现# collections.namedtuple 是一个工厂函数，它可以用来构建一个带字段名的元组和一个有名字的类。# namedtuple 构建的类的实例锁消耗的内存和元组是一样的，因为字段名都被存放在对应的类里。这个实例和普通的对象实例相比也更小一些，# 因为 在这个实例中，Python 不需要用 __dict__ 来存放这些实例的属性```## 21 切片进阶### 给切片赋值```l = list(range(10))print(l)# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]l[2: 5] = [20, 30]print(l)# [0, 1, 20, 30, 5, 6, 7, 8, 9]# 从0开始计数del l[5:7]print(l)# [0, 1, 20, 30, 5, 8, 9]l[3::2] = [11, 22]print(l)# [0, 1, 20, 11, 5, 22, 9]l[2: 5] = 100# TypeError: can only assign an iterable# 如果赋值的对象是一个切片，那么赋值语句的右侧必须是一个可迭代对象。```### 给切片命名```# 如果代码中已经出现了大量的无法直视的硬编码切片下标，可以使用给切片命名的方式清理代码# 比如你有一段代码要从一个记录字符串中几个固定位置提取出特定的数据字段# 比如文件或类似格式 :# 01234567890123456789012345678901234567890123456789012345678901234record = '............100....513.25........'# cost = int(record[20:23]) * float(record[31:37])# 这时，可以先给切片命名,以避免大量无法理解的硬编码下标，使代码可读性更强SHARES = slice(20, 23)PRICE = slice(31, 37)print(SHARES, PRICE)# cost = int(record[SHARES] * float[record[PRICE]])# slice() 函数创建了一个切片对象，可以被用在任何切片允许使用的地方items = [0, 1, 2, 3, 4, 5, 6]a = slice(2, 4)print(items[2: 4])print(items[a])items[a] = [10, 11]print(items)# 如果你有一个切片对象 a，还可以调用 a.start, a.stop, a.step 来获取更多信息:a = slice(5, 50, 2)print(a.start)print(a.step)```## 22 为什么下标要从0开始> Python 里的范围（range）和切片都不会返回第二个下标所指的元素?  > 为了表示出自然数的子序列，2, 3, ... , 12，不使用省略记号那三个点号，我们可以选择4种约定方式：    > a)2 <= i < 13  > b)1 < i <= 12  > c)2 <= i <=12  > d)1 < i < 13  > 可以观察到，  > (1)a) 和 b)有个优点，上下边界的相减得到的差，正好等于子序列的长度  > (2)假如两个子序列相邻的话，其中一个序列的上界，就等于另一个序列的下界> 但上面观察，并不能让我们从a), b)两者中选出更好的一个。让我们重新开始分析。> > 一定存在最小的自然数。假如像b)和d)那样，子序列并不包括下界，> 那么当子序列从最小的自然数开始算起的时候，会使得下界进入非自然数的区域。  > 比如要表示 0, 1, 2, 3 如果用 b) d) 的方式，下界就要表示成 -1 < i> 这就比较丑陋了。  >  所以对于下界来说，我们更应该采用≤，正如a)或c)那样。> > 现在考虑，假如子序列包括上界，> 那么当子序列从最小的自然数开始算起，并且序列为空的时候，上界也会进入非自然数的区域。  > 如果一个空序列用 c) 其实是无法表示的,用 a) 则可以表示成 0 ≤ i < 0> 这也是丑陋的。  > 所以，对于上界，我们更应该采用 <, 正如a)或b)那样。因此我们得出结论，约定a)是更好的选择。## 23 导入模块的作用范围```# study_321.pyprint('今天练习1')print(__name__)if __name__ == '__main__':	print('今天练习2')``````# import_test.pyimport study_321# 与之前study_321.py代码运行结果比较，只有输出"今天练习1"，# 也就是if __name__=="__main__": 之前的语句被执行，之后的没有被执行。# 在study_321.py脚本的if __name__=="__main__":# 之前加入 print(__name__)，即将__name__打印出来# 再执行import_test.py# 输出："今天练习1"，"study_321"# import_321.py中的__name__变量值为test，# 不满足__name__=="__main__"的条件，因此，无法执行其后的代码。# 由于每个python模块（python文件）都包含内置的变量__name__，当运行模块被执行的时候，__name__等于文件名（包含了后缀.py）。# 如果import到其他模块中，则__name__等于模块名称（不包含后缀.py）。而“__main__”等于当前执行文件的名称（包含了后缀.py）。# 所以当模块被直接执行时，__name__ == '__main__'结果为真；# 而当模块被import到其他模块中时，__name__ == '__main__'结果为假，就是不调用对应的方法。# 简而言之就是：__name__ 是当前模块名，当模块被直接运行时模块名为 __main__ 。# 当模块被直接运行时，代码将被运行，当模块是被导入时，代码不被运行。print(__name__)# __name__=="__main__"if __name__ == '__main__':	print('今天练习3')	# print(study_321.main())	# 找不到方法study_321.main()```## 24 with语句中的上下文对象处理```# method 1class A:    def __enter__(self):        print('__enter__() is called')    def __exit__(self, exc_type, exc_val, exc_tb):        print('__exit__() is called')        if exc_type is ZeroDivisionError:            print('Please DO NOT Divide BY zero!')            return Truewith A() as a:    print('in with code black')    b = 1/0# method 2from contextlib import contextmanager@contextmanagerdef A():    try:        print('__enter__() is called')        yield    except ZeroDivisionError:        print('Please DO Not Divide by zero!')    finally:        print('__exit__() is called')with A():    print('IN with code black')    b = 1/0```## 25 tuple只有一个对象的使用```# 定义一个空tupleT = ()# 当元组只有一个对象时，不能用T = ('hello')print(type(T))# <class 'str'># 这相当于使用 T = 'hello'# 而应该使用T = ('hello',)print(type(T))# <class 'tuple'># list 和 tuple 之间可互相转化：L = [3, 4, "hello"]T = tuple(L)print(T)# (3, 4, 'hello')T = (3, 4, 'hello')L = list(T)print(L)# [3, 4, 'hello']```## 26 class定义与def的区别```print("A")class Person(object):    print("B")    def __init__(self,name):        print("C")        self.name = name        # 这个函数的主体代码被不会立即执行，而是被编译成中间码，并返回一个函数对象。        # 这意味着只要函数主体没有包含任何语法错误（包含缩进错误），就能成功返回一个函数对象。        # 使用“def” 在类的内部创建了一个新的函数对象，用和这个函数同样的名称创建了一个类级别的属性。    print("D")        # 类逐行定义print("E")p1 = Person("name1")# 实例化时执行__init__# A B D E Cp2 = Person("name2")# C```